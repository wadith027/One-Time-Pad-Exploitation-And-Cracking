__author__ = "Shadman Wadith"
__copyright__ = "Copyright 2022, Cryptography and Network Security Lab"
__license__ = "Apache-2.0"
__version__ = "1.0"
__email__ = "wadith.24csedu.027@gmail.com"
__status__ = "Production"

"""
Description :   This following code is for cracking the ciphertext encrypted
                using One Time Pad with the following function 
                Ci = Mi ^ (( Pi + C(i-1) ) % 256) As this function is not         
                like normal one time pad. It can't be cracked with usual 
                cracking technique. So we followed an backtracking with pruning 
                approach where we test all possible keys and check whether the 
                word created is in English dictionary or not   
                 
                

Caution :       This cracking technique will only work on English Text only
                If you want to decrypt any other language ciphertext then
                You have to have dictionary set of that language in the word.txt
                file.
                
                Also this decryption technique might be error prone. So it's not 
                100% correct                                     
"""

key_list = []  # Possible key set list extracted from the given ciphertext
message = [''] * 10  # This is the predicted message after decrypting the ciphertexts
words_built = [''] * 10
# It's storing the last words generated from a message to check that if it's in dictionary or not
dictionary = []  # storing all the words in english dictionary
potential_key = ""  # Pad/Key for all the ciphers
ERROR_TOLERANCE = 1  # Used for checking errors in words


def stringToIntList(msg):
    """
    This function converts the list of ascii character to ascii value
    :param msg:
    :return: returns a list of the ascii values
    """
    array = []
    for i in range(len(msg)):
        array.append(ord(msg[i]))
    return array


def loadCiphertexts(file):
    """
    This function Loads all the cipher text from input.txt file
    and convert them to list of integers which are basically ascii
    value of characters
    :param file:
    :return: a list of integers
    """
    array = []
    while True:
        ciphertext_txt = file.readline()
        if len(ciphertext_txt) == 0:
            break
        ciphertext_txt_trimmed = ''
        # The loop below cleans [ ] (third brackets from the input function and store just the numbers
        for character in ciphertext_txt:
            if (character >= '0' and character <= '9') or character == ' ':
                ciphertext_txt_trimmed += character
        ciphertext_int = [int(number) for number in ciphertext_txt_trimmed.split()]
        array.append(ciphertext_int)
    return array


def isValid(key, position, cipher_array):
    """
    This function checks for valid keys as our valid set is
    "A-Z,a-z,space , , . ? ! - ( )". So we basically check for
    all possible keys(0-255) and check that all the cipher text
    in the same column have a key in the valid set
    :param key:
    :param position:
    :param cipher_array:
    :return:
    """
    count_flag = 0
    for i in range(10):
        if position == 0:
            previous_ciphertext = 0
        else:
            previous_ciphertext = cipher_array[i][position - 1]  # it's Ci-1th positioned ciphertext
        decrypted_part = cipher_array[i][position] ^ ((previous_ciphertext + key) % 256)
        t = chr(decrypted_part)  # possible plain text character
        if ('a' <= t <= 'z') or (
                'A' <= t <= 'Z') or t == ' ' or t == ',' or t == '?' or t == '.' or t == '!' or t == '-' or t == '(' or t == ')':
            count_flag += 1
        else:
            break
        if count_flag == len(cipher_array):
            # As we have 10 ciphertexts. So when the count will be 10 it will return true
            return True
    return False


def findKey(ciphertexts_array):
    """
    Method for finding all possible key sets per column
    :param ciphertexts_array:
    :return:
    """
    keys = []
    for i in range(60):
        key_column = []
        check = 0
        for key_index in range(256):
            if isValid(key_index, i, ciphertexts_array):  # Check if the key is valid or not
                check += 1
                if check == 1:
                    key_list.append(key_index)
                key_column.append(key_index)
        keys.append(key_column)
    return keys


def decryptPosition(key, position, ciphertext):
    """
    Just decrypts the ith positioned message using Mi = Ci ^ (( Ki + Ci-1 ) % 256 )
    :param key:
    :param position:
    :param ciphertext:
    :return:
    """
    if position == 0:
        previous_cipher_byte = 0
    else:
        previous_cipher_byte = ciphertext[position - 1]

    decrypted_part = ((key + previous_cipher_byte) % 256) ^ ciphertext[position]
    return chr(decrypted_part)


def checkDict(position, message, words_built):
    """
    Function for checking a word from the message is in the dictionary or not
    :param position:
    :param message:
    :param words_built:
    :return:
    """
    # print(position)
    # print(message)
    # print(words_built)
    error = 0  # Error count variable for checking words in dictionary

    for i in range(10):
        word = ""
        if words_built[i] == '':
            j = position - 1  # Last position of the word in message array
            while message[i][j] != ' ' and j >= 0:
                # Checking there is a space in the word as words are separated with space
                word += message[i][j]
                j -= 1
            word = word[::-1]  # reversing the string because we are storing characters in reverse order
            word = word.lower()
            if word != '' and word not in dictionary:  # checking the word is in dictionary
                # print("error for : " + word)
                error += 1
    # print("error : " + str(error))
    return error


def crackPad(keys, ciphers, position, end):
    """
    Recursive function for checking all possible combination from the key set
    That will fill up the potential key values
    :param keys: Possible key set
    :param ciphers: List of CipherText
    :param position:
    :param end:
    :return:
    """
    global potential_key
    if position == end:
        return True
    for key in keys[position]:
        for i in range(len(ciphers)):
            m = decryptPosition(key, position, ciphers[i])  # decrypted character
            message[i] = message[i] + m  # appending it with the message
            if 'a' <= m <= 'z' or 'A' <= m <= 'Z':
                # we add the character to the array if it's an alphabet
                # to build a word
                # If the character is not any alphabet then it will
                # be any punctuation or space Which will indicate that
                # the following message was an end of a word then we would
                # check for that word if it is in dictionary or not
                words_built[i] = words_built[i] + m
            else:
                # print(words_built)
                words_built[i] = ''
            # print(message)
        if checkDict(position, message, words_built) <= ERROR_TOLERANCE:
            # Here checkDict functions check for word in every line
            # It counts the number of words that are not in the dictionary
            # Here we are tolerating an error of 1 as there might be some
            # words which are abbreviation that are not in the dictionary
            if crackPad(keys, ciphers, position + 1, end):  # the recursion call and return the key
                potential_key += chr(key)  # keys will be inserted in a reverse order for the recursion
                # print("Potential Keys : " + potential_key)
                return True
        for i in range(len(message)):
            # Slicing the last character from all the messages and words
            message[i] = message[i][:-1]
            words_built[i] = words_built[i][:-1]
    return False


if __name__ == '__main__':
    input_file = open("input.txt", "r")
    dictionary_file = open("word.txt", "r")
    ciphertexts_array = loadCiphertexts(input_file)
    # print(ciphertexts_array[0])
    key_set = findKey(ciphertexts_array)
    # print(key_set)
    # for x in key_set:
    #     print(len(x))
    dictionary = set(dictionary_file.read().split())  # English Dictionary word set
    start_position = 0
    # potential_key = [0] * 60
    crackPad(key_set, ciphertexts_array, start_position, len(key_set))
    potential_key = potential_key[::-1]

    # Printing the key in reverse as my key array was getting input in reverse order
    # for the recursive function
    print("\n____________________Decrypted Message______________________  \n")
    for msg in message:
        print(msg)
    print("------------------------------------------------------------")
    print("Key:")
    print(potential_key)

    # Test Purpose Code
    # key = "WKt3UqHiLNrOT1GeGXtNqfqWTA37c8kEtinmaqOjzDBbMHpH75h6cGWaDbp1"
    # key_int = stringToIntList(key)
    # # print(key_int)
    # for x in ciphertexts_array:
    #     m = ''
    #     for i in range(60):
    #         m = m + decryptPosition(key_int[i], i, x)
    #     print(m)
    # decrypt(ciphertexts_array, dictionary, rslt2)

    dictionary_file.close()
    input_file.close()

# key =  WKt3UqHiLNrOT1GeGXtNqfqWTA37c8kEtinmaqOjzDBbMHpH75h6cGWaDbp1

"""
Final decrypted message..........

we stand today on the brink of a revolution in cryptography.
probabilistic encryption is the use of randomness in an encr
secure Sockets Layer (SSL), are cryptographic protocols that
this document will detail a vulnerability in the ssh cryptog
mIT developed Kerberos to protect network services provided 
nIST announced a competition to develop a new cryptographic 
diffie-Hellman establishes a shared secret that can be used 
public-key cryptography refers to a cryptographic system req
the keys used to sign the certificates had been stolen from 
we hope this inspires others to work in this fascinating fie
"""
